# ORDER BY 처리(Using filesort)
## ORDER BY 
- 정렬을 처리하기 위해서는 인덱스를 이용하는 방법과 쿼리가 실행될 때 **Filesort** 라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.
> 1. 인덱스를 이용  
>    - 장점  
>      * INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.
>    - 단점  
>      * INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
>      * 인덱스 때문에 디스크 공간이 더 많이 필요하다.
>      * 인덱스가 개수가 늘어날수록 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시용 메모리가 많이 필요하다.
> 2. Filesort 이용
>    - 장점  
>      * 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.
>      * 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
>    - 단점  
>      * 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.  

- 인덱스를 이용한 정렬과 같이 레코드를 정렬하기 위해 항상 **Filesort** 라는 정렬 작업을 거쳐야 하는 것은 아니다. 하지만 아래와 같은 이유로 모든 정렬이 인덱스를 이용하도록 튜닝하기란 거의 불가능하다.
> - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
> - GROUP BY 의 결과 또는 DISTINCT 와 같은 처리의 결과를 정렬해야 하는 경우
> - UNION의 결과와 같이 임시 테이블 결과를 다시 정렬해야 하는 경우
> - 랜덤하게 결과 레코드를 가져와야 하는 경우  

MariaDB가 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 컬럼에 **Using filesort** 라는 코멘트가 표시되는지로 판단할 수 있다.

- - -
## 소트 버퍼(Sort buffer)
- MariaDB는 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라 한다. 최대 사용 가능한 소트 버퍼의 공간은 **sort_buffer_size** 라는 시스템 변수로 설정할 수 있다. 스토리지 엔진에서는 기본적으로 내부 임시 테이블을 위해 Aria 스토리지 엔진을 사용하기 때문에 이 경우에는 **aria_sort_buffer_size 로 설정이 가능하다.
> - 소트 버퍼 크기는 256KB 에서 512KB 사이에서 최적의 성능을 보이는 것 같다. 56KB에서 1MB 적당하게 설정해서 사용 하도록 하자.
- - -
## 정렬 알고리즘
- 싱글 패스(Single pass) 알고리즘
> - 소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 되는 컬럼 전부를 담아서 정렬을 수행하는 방법이며, MySQL 5.0 이후 최근 도입
> - 투 패스 알고리즘 보다는 빠르지만 정렬 버퍼를 두배 정도 사용한다. 조회를 두 번 하기 떄문에.  
>   * 정렬 대상 레코드의 크기나 건수가 작은 경우 빠름.

- 투 패스(Two pass) 알고리즘
> - 정렬 대상 칼럼과 프라이머리 키 값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 할 컬럼을 가져오는 알고리즘으로, MySQL 5.0 이전에서 사용하던 방법이다.
> - 싱글 패스 알고리즘 보다는 느리지만 정렬 버퍼를 절반 정도만 사용한다. 조회를 한 번에 하기 때문에.
>   * 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적.
> - 최근의 MariaDB 5.x 버전에서는 일반적으로 새로운 정렬 알고리즘인 싱글 패스 방식을 사용한다. 하지만 항상 싱글 패스 정렬 알고리즘을 사용하는 것은 아니다. 다음 과 같을 때 싱금 패스 방식을 사용하지 못하고 투 패스 정렬 알고리즘을 사용한다.
> > 1. 레코드의 크기가 max_length_sort_data 파라미터로 설정된 값보다 클 떄
> > 2. BLOB 이나 TEXT 타입의 컬럼이 SELECT 대상에 포함할 때

- 참고: SELECT 쿼리를 실행할 시에는 **(*)** 를 사용하지 말고 꼭 **필요한 컬럼만** 조회하도록 하자. 정렬 퍼버를 몇 배에서 몇 십배까지 비 효율적으로 사용하게 만든 가능성이 크다. 이 뿐 아니라 임시 테이블이 필요한 테이블에서도 영향을 미친다.
- - -
## 정렬의 처리 방식
- ORDER BY 3가지 방식 (빠른 순위, 실행 순위(인덱스 사용 못하면 filesort(정렬버퍼) 사용))
    1. 인덱스 사용한 정렬 
        * 실행 계획 Extra 코멘트 - 없음
    2. 드라이빙 테이블만 정렬(조인이 없는 경우 포함)
        * 실행 계획 Extra 코멘트 - **Using filesort** 표기
    3. 조인 결과를 임시 테이블로 저장한 후, 임시 테이블에서 정렬
        * 실행 계획 Extra 코멘트 - **Using temporary; Using filesort** 같이 표기

### 인덱스를 사용한 정렬
> ORDER BY 에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 그리고 B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다. 여러 테이블이 조인되는 경우에는 네스티드-루프(Nested-loop) 방식의 조인에서만 이 방식을 사용할 수 있다.
<pre>
SELECT * FROM employees e, salaries s
 WHERE s.emp_no = e.emp_no
   AND e.emp_no BETWEEN 100002 AND 100020
 ORDER BY e.emp_no;
</pre>
- 자동 정렬이 된다고 하여도 정렬은 명시하도록 하자. 예상치 못한 버그가 발생할 수 있다.

### 드라이빙 테이블만 정렬
> 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어난다. 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 모든 조인의 결과를 통째로 정렬하는 것보다는 효율적이다. 이 방법은 조인에서 첫 번째 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절이 작성돼야 한다.
<pre>
SELECT * FROM employees e, salaries s
 WHERE s.emp_no = e.emp_no
   AND e.emp_no BETWEEN 100002 AND 100010
 ORDER BY e.last_name;
</pre>
> - WHERE 절의 검색 조건 (emp_no BETWEEN 100002 AND 100010)은 employees 테이블의 PK를 이용해서 검색하면 작업량을 줄일 수 있다.
> - 드리븐 테이블(salaries)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다.  

- 검색은 인덱스 레인지 스캔으로 처리할 수 있지만 ORDER BY 절에 명시된 컬럼은 employees 테이블의 PK와 전혀 연관이 없으므로 인덱스를 이용한 정렬은 불가능하다. 그런데 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블(employees)에 포함된 컬럼임을 알 수 있다. 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고, 그 결과와 salaries 테이블을 조인한 것이다.
> 1. 인덱스를 이용해서 "emp_no BETWEEN 100002 AND 100010" 조건을 만족하는 9건을 검색
> 2. 검색 결과를 last_name 컬럼으로 정렬을 수행(Filesort)
> 3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해서 86건의 최종 결과를 가져옴
### 임시 테이블을 이용한 정렬
- 이번 쿼리에서는 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블(employees이 아니라 드리븐 테이블(salaries)에 있는 컬럼이다. 즉 정렬이 수행되기 전에 반드시 salaries 테이블을 읽어야 하므로 이 쿼리는 반드시 조인된 데이터를 가지고 정렬할 수밖에 없다.
<pre>
SELECT * FROM employees e, salaries s
 WHERE s.emp_no = e.emp_no
   AND e.emp_no BETWEEN 100002 AND 100020
 ORDER BY s.salary;
</pre>
> - 실행 계획을 보면 Extra 컬럼에 "Using temporary; Using filesort" 라는 코멘트가 표시된다. 이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리 했음을 의미한다.

### 정렬 방식의 성능 비교 
> ORDER BY 나 GROUP BY와 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서는 처리될 수 없다. 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그룹핑 작업을 실행해야만 비로소 LIMIT로 건수를 제한을 할 수 있다. WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY 나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다. 이를 위해 쿼리가 처리되는 방법을 "스트리밍 처리" 와 "버퍼링 처리" 라는 2가지 방식으로 구분해보자.

### 스트리밍(Streaming) 방식(인덱스 정렬만)
> - 서버 쪽에서 처리해야 할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식을 의미한다. 스트리밍 방식으로 처리 되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해 준다.
- 스트리밍 처리는 어떤 클라이언트 도구나 API를 사용하느냐에 따라 그 방식에 차이가 있을 수 있다. JDBC 와 같은 경우는 마지막 레코드가 전달 될때 까지 자체적인 버퍼에 담아 두었다가 그때서야 어플리케이션으로 반환한다. 즉 JDBC 라이브러리가 버퍼링을 하는 것이다. 불필요한 네트워크 요청이 최소화되기 때문에 스루풋이 뛰어난 것이다. 아주 대량의 데이터를 가져와야 할 때는 전송 방식을 스트리밍으로 변경할 수 있다.

### 버퍼링(Buffering) 방식
> - ORDER BY 나 GROUP BY 와 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다. 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그룹핑을 해서 차례대로 보내야 하기 때문이다. 응답 속도가 느려지는 것이다.
> - 일반적으로 RDBMS의 조인에서는 WHERE 조건에 일치하는 대상 **레코드 건수가 적은 쪽 테이블을 우선적으로 드라이빙 테이블**로 선정하게 된다.
> - 가능하다면 **인덱스**를 사용한 정렬로 유도하고 그렇지 못하다면 최소한 **드라이빙 테이블**만 정렬해도 되는 수준으로 유도 하는 것도 좋은 튜닝 방법이다.

### 정렬 관련 상태 변수
> - 정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업(멀티 머지)은 몇 번이나 발생했는지 등을 다음과 같은 명령으로 확인해 볼 수 있다.
<pre>
SHOW SERSSION STATUS LIKE 'Sort%';
SELECT first_name, last_name FROM employees GROUP BY first_name, last_name;
SHOW SERSSION STATUS LIKE 'Sort%';
</pre>
> - Sort_merge_passes 는 멀티 머지 처리 횟수를 의미한다.
> - Sort_range 는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다.
> - Sort_scan 은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다. Sort_scan과 Sort_range는 둘 다 정렬 작업 횟수를 누적하고 있는 상태 값이다.
> - Sort_rows 는 지금까지 정렬한 전체 레코드 건수를 의미한다.
